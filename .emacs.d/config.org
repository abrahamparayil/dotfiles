#     _    _               _                       ____        _ _  _
#    / \  | |__  _ __ __ _| |__   __ _ _ __ ___   |  _ \ __ _ (_|_)\_/ ___ 
#   / _ \ | '_ \| '__/ _` | '_ \ / _` | '_ ` _ \  | |_) / _` || | |  / __|
#  / ___ \| |_) | | | (_| | | | | (_| | | | | | | |  _ < (_| || | |  \__ \
# /_/   \_\_.__/|_|  \__,_|_| |_|\__,_|_| |_| |_| |_| \_\__,_|/ |_|  |___/
#                                                         |__/       
#  _____                                             __ _       
# | ____|_ __ ___   __ _  ___ ___    ___ ___  _ __  / _(_) __ _ 
# |  _| | '_ ` _ \ / _` |/ __/ __|  / __/ _ \| '_ \| |_| |/ _` |
# | |___| | | | | | (_| | (__\__ \ | (_| (_) | | | |  _| | (_| |
# |_____|_| |_| |_|\__,_|\___|___/  \___\___/|_| |_|_| |_|\__, |
#                                                          |___/ 

#+TITLE: Emacs Config
#+AUTHOR: Abraham Raji
#+EMAIL: abrahamraji99@gmail.com
#+STARTUP: overview
#+CREATOR: avronr
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: style margin-left: auto; margin-right: auto;

* User Info
  Name and Email.
  #+BEGIN_SRC emacs-lisp
     (setq user-full-name "Abraham Raji"
               user-email "abrahamraji99@gmail.com")
  #+END_SRC
* Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC
* Package Management
This piece of code tells emacs where to find packages from or in more proper they are called 'repositories'. I personally use MELPA, ELPA and the official org-mode repo to get the latest version of orgmode. So keep what you want take out there rest. Oh and asuming you are new to elisp and emacs while editting these lines watch for the '()' and you should be fine.
#+BEGIN_SRC emacs-lisp
(require 'package)
 (setq package-archives
  '(("melpa" . "https://melpa.org/packages/")
    ("gnu" . "https://elpa.gnu.org/packages/")
    ("org" . "http://orgmode.org/elpa/")))
(package-initialize)
#+END_SRC

Occasionally emacs will tell you it can't find a package in any of your declared repos all you will have to do is refresh your repositories. Unless the package doesn't actually exist in the repos the problem should be fixed. 

You can install the packages manually by:
1. first hit [Meta] and x 
2. then type 'package-install' and hit enter
3. then type in the name of the package you wish to install and hit enter again.
If the package exists in the repositories that you have asked emacs to look in, the packages will be installed or you will recieve an error message. If we directly use use package command in our config it will install the packages everytime emacs starts up even if they're already installed so we cannot use it in our configs.
You could also alternatively download packages as an archive file from the repos like the ones mentioned above and ask emacs to install them from the file. But unless you are developing packages for emacs and wish to test your package before publishing it, I do not recommend this method.
As you may have noticed both process are a bit tedious and will only get worse as time goes by. A better approach in my opinion would be to use a package manager like use-package which is what I do. You just need i the name of the package you wish to install and it will do the rest including updating the package.
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package) ;;lisp equivalent of a while loop 
(package-install 'use-package);; We're using package install to install use-package
(setq load-prefer-newer t));; to install newer version when available
(setq use-package-verbose t);; This line is just a raincheck
(setq use-package-always-ensure t);;Always ensure that the package is installed
(require 'use-package)
#+END_SRC 
And that's about it for package management.
* Multiplexing emacs and emacsclient
Opening a new file in the same emacs-session requires the use of emacsclient. emacs command can be itself wrapped to do the smarter job to open the file if the session exists. To start session you need to start-server. This snippet will create server in first session of emacs. Add this to your emacs configuration file
#+BEGIN_SRC emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))
#+END_SRC

To make this work you need to add this to you .bashrc:
#+BEGIN_SRC sh
function emacs {
    if [[ $# -eq 0 ]]; then
        /usr/bin/emacs # "emacs" is function, will cause recursion
        return
    fi
    args=($*)
    for ((i=0; i <= ${#args}; i++)); do
        local a=${args[i]}
        # NOTE: -c for creating new frame
        if [[ ${a:0:1} == '-' && ${a} != '-c' && ${a} != '--' ]]; then
            /usr/bin/emacs ${args[*]}
            return
        fi
    done
    setsid emacsclient -n -a /usr/bin/emacs ${args[*]}
} 
#+END_SRC
* Syntax highlighting for systemd Files
Add Syntax highlighting for your systemd Files.
#+BEGIN_SRC emacs-lisp
 (add-to-list 'auto-mode-alist '("\\.service\\'" . conf-unix-mode))
 (add-to-list 'auto-mode-alist '("\\.timer\\'" . conf-unix-mode))
 (add-to-list 'auto-mode-alist '("\\.target\\'" . conf-unix-mode))
 (add-to-list 'auto-mode-alist '("\\.mount\\'" . conf-unix-mode))
 (add-to-list 'auto-mode-alist '("\\.automount\\'" . conf-unix-mode))
 (add-to-list 'auto-mode-alist '("\\.slice\\'" . conf-unix-mode))
 (add-to-list 'auto-mode-alist '("\\.socket\\'" . conf-unix-mode))
 (add-to-list 'auto-mode-alist '("\\.path\\'" . conf-unix-mode))
 (add-to-list 'auto-mode-alist '("\\.netdev\\'" . conf-unix-mode))
 (add-to-list 'auto-mode-alist '("\\.network\\'" . conf-unix-mode))
 (add-to-list 'auto-mode-alist '("\\.link\\'" . conf-unix-mode))
#+END_SRC
* Async
  Lets us use asynchronous processes wherever possible, pretty useful.
  #+BEGIN_SRC emacs-lisp
    (use-package async
    :ensure t
    :init (dired-async-mode 1))
  #+END_SRC
* Backups
This is one of the things people usually want to change right away. Bydefault, Emacs saves backup files in the current directory. These are the files ending in =~= that are cluttering up your directory lists. The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.
#+begin_src emacs-lisp
(setq backup-directory-alist 
      '(("." . "~/.emacs.d/backups")))
;; autosave the undo-tree history
(setq undo-tree-history-directory-alist
      `((".*" . ,temporary-file-directory)))
#+end_src
 Disk space is cheap. Save lots.
 #+begin_src emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
 #+end_src
* Hydra
This is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra.
Imagine that you have bound C-c j and C-c k in your config.  You want to call C-c j and C-c k in some (arbitrary) sequence. Hydra allows you to:
- Bind your functions in a way that pressing C-c jjkk3j5k is equivalent to pressing C-c j C-c j C-c k C-c k M-3 C-c j M-5 C-c k. Any key other than j or k exits this state.

- Assign a custom hint to this group of functions, so that you know immediately after pressing C-c that you can follow up with j or k.

If you want to quickly understand the concept, see [the video demo](https://www.youtube.com/watch?v=_qZliI1BKzI).

#+BEGIN_SRC emacs-lisp
  (use-package hydra 
    :ensure hydra
    :init 
    (global-set-key
    (kbd "C-x t")
	    (defhydra toggle (:color blue)
	      "toggle"
	      ("a" abbrev-mode "abbrev")
	      ("s" flyspell-mode "flyspell")
	      ("d" toggle-debug-on-error "debug")
	      ("c" fci-mode "fCi")
	      ("f" auto-fill-mode "fill")
	      ("t" toggle-truncate-lines "truncate")
	      ("w" whitespace-mode "whitespace")
	      ("q" nil "cancel")))
    (global-set-key
     (kbd "C-x j")
     (defhydra gotoline 
       ( :pre (linum-mode 1)
	      :post (linum-mode -1))
       "goto"
       ("t" (lambda () (interactive)(move-to-window-line-top-bottom 0)) "top")
       ("b" (lambda () (interactive)(move-to-window-line-top-bottom -1)) "bottom")
       ("m" (lambda () (interactive)(move-to-window-line-top-bottom)) "middle")
       ("e" (lambda () (interactive)(end-of-buffer)) "end")
       ("c" recenter-top-bottom "recenter")
       ("n" next-line "down")
       ("p" (lambda () (interactive) (forward-line -1))  "up")
       ("g" goto-line "goto-line")
       ))
    (global-set-key
     (kbd "C-c t")
     (defhydra hydra-global-org (:color blue)
       "Org"
       ("t" org-timer-start "Start Timer")
       ("s" org-timer-stop "Stop Timer")
       ("r" org-timer-set-timer "Set Timer") ; This one requires you be in an orgmode doc, as it sets the timer for the header
       ("p" org-timer "Print Timer") ; output timer value to buffer
       ("w" (org-clock-in '(4)) "Clock-In") ; used with (org-clock-persistence-insinuate) (setq org-clock-persist t)
       ("o" org-clock-out "Clock-Out") ; you might also want (setq org-log-note-clock-out t)
       ("j" org-clock-goto "Clock Goto") ; global visit the clocked task
       ("c" org-capture "Capture") ; Don't forget to define the captures you want http://orgmode.org/manual/Capture.html
	     ("l" (or )rg-capture-goto-last-stored "Last Capture"))

     ))

(defhydra hydra-multiple-cursors (:hint nil)
  "
 Up^^             Down^^           Miscellaneous           % 2(mc/num-cursors) cursor%s(if (> (mc/num-cursors) 1) \"s\" \"\")
------------------------------------------------------------------
 [_p_]   Next     [_n_]   Next     [_l_] Edit lines  [_0_] Insert numbers
 [_P_]   Skip     [_N_]   Skip     [_a_] Mark all    [_A_] Insert letters
 [_M-p_] Unmark   [_M-n_] Unmark   [_s_] Search
 [Click] Cursor at point       [_q_] Quit"
  ("l" mc/edit-lines :exit t)
  ("a" mc/mark-all-like-this :exit t)
  ("n" mc/mark-next-like-this)
  ("N" mc/skip-to-next-like-this)
  ("M-n" mc/unmark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("P" mc/skip-to-previous-like-this)
  ("M-p" mc/unmark-previous-like-this)
  ("s" mc/mark-all-in-region-regexp :exit t)
  ("0" mc/insert-numbers :exit t)
  ("A" mc/insert-letters :exit t)
  ("<mouse-1>" mc/add-cursor-on-click)
  ;; Help with click recognition in this hydra
  ("<down-mouse-1>" ignore)
  ("<drag-mouse-1>" ignore)
  ("q" nil)


  ("<mouse-1>" mc/add-cursor-on-click)
  ("<down-mouse-1>" ignore)
  ("<drag-mouse-1>" ignore))
#+END_SRC
* Themes
   I'm a dark theme person. Another theme I'd suggest is the =liso-theme=.
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
:ensure t)
(load-theme ' doom-molokai t)
(setq sml/no-confirm-load-theme t)
; Global settings (defaults)
(setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
doom-themes-enable-italic t) ; if nil, italics is universally disabled
;; Corrects (and improves) org-mode's native fontification.
(doom-themes-org-config)
#+END_SRC
* Dashboard
As you may have seen when you start-up Emacs you are welcomed with a pretty boring welcome screen. It's not terrible, infact most of it is either to help you or for other functional purposes but a bit ugly nontheless. Since we're past the novice level or because you're reading this, it's safe to persume that you won't be using any of those so we might as well take it out and put on something good looking. I wouldn't claim that my dashboard is that good looking but it's functionality i believe makes up for it. the dashboard lists the most recent 5 files and projects that you have accessed. It also has a welcome message which you can configure it to say whatever you want, mine just says "Hey Abraham!". You must also notice that a new package is going to be installed for this functionality. If you want to keep things minimal you can skip this section.
#+BEGIN_SRC emacs-lisp
(use-package dashboard
:config
      (dashboard-setup-startup-hook)
      (page-break-lines-mode -1)
;; configure initial-buffer-choice to show Dashboard in frames created with emacsclient -c
(setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))  
;; To customize which widgets are displayed, you can use the following snippet
      (setq dashboard-items '((recents  . 10)
                              (projects . 10)))
;; Set the banner   
      (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")    
;; Set the title
      (setq dashboard-banner-logo-title "Hey, Abraham!")
;; Content is not centered by default. To center, set
      (setq dashboard-center-content t)
;; To show navigator below the banner:
      (setq dashboard-set-navigator t)
      (setq dashboard-set-file-icons t)
;; Format: "(icon title help action face prefix suffix)"
(setq dashboard-navigator-buttons
      `(;; line1
        ((,(all-the-icons-octicon "mark-github" :height 1.1 :v-adjust 0.0)
         "Github"
         "Browse Github"
         (lambda (&rest _) (browse-url "https://github.com/avronr")))
	 (,(all-the-icons-faicon "gitlab" :height 1.1 :v-adjust 0.0)
         "Gitlab"
         "Browse Gitlab"
         (lambda (&rest _) (browse-url "https://gitlab.com/avronr")))

        ("" "Homepage" "Show Homepage" (lambda (&rest _)(browse-url "https://avronr.gitlab.io/")))))))

#+END_SRC
* Short Settings
- Inhibit Startup Message
  #+BEGIN_SRC emacs-lisp
   (setq inhibit-startup-message t)
  #+END_SRC
- Disables Toolbar
   #+BEGIN_SRC emacs-lisp
   (tool-bar-mode -1)
   #+END_SRC
- Text wrapping
   #+BEGIN_SRC emacs-lisp
      (setq visual-line-mode t)
   #+END_SRC
- Use y/n instead of yes/no
  #+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)   
  #+END_SRC
- make home and end buttons do their job
  #+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<home>") 'move-begining-of-line)
  (global-set-key (kbd "<end>") 'move-end-of-line)
  #+END_SRC
-  don't require two spaces for sentence end.
  #+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
  #+END_SRC
-  The beeping can be annoying--turn it off
  #+BEGIN_SRC emacs-lisp
  (setq visible-bell t
          ring-bell-function 'ignore)
  #+END_SRC
- Start in fullscreen
  #+BEGIN_SRC emacs-lisp
  ;(toggle-frame-fullscreen)
  #+END_SRC
- Kill current buffer
  #+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x w") 'kill-current-buffer)
  #+END_SRC
- Setting keybinding for eshell
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<M-return>") 'eshell)
#+END_SRC
* Eshell
My frustration with shells makes me enjoy Emacs Shell, but there aresome significant differences to address. To this end, I [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][documented most features]].
I find it a shame that I can not successfully use =use-package= with the=eshell = package. It loads quick enough, that I'll simply deal with it.
** Basics
*** Set up the Correct Path
   Need the correct PATH even if we start Emacs from the GUI:
   #+BEGIN_SRC emacs-lisp
     (setenv "PATH"
             (concat
              "/usr/local/bin:/usr/local/sbin:"
              (getenv "PATH")))
   #+END_SRC
*** Pager Setup
   If any program wants to pause the output through the =$PAGER= variable, well, we don't really need that:
   #+BEGIN_SRC emacs-lisp
     (setenv "PAGER" "cat")
   #+END_SRC
*** Navigation and Keys

   Eshell comes with some interesting features:
   - ~M-RET~ can be used to accumulate further commands while a command is currently running.  Since all input is passed to the subprocess being executed, there is no automatic input queueing as there is with other shells.
   - ~C-c C-t~ can be used to truncate the buffer if it grows too large.
   - ~C-c C-r~ will move point to the beginning of the output of the last command.  With a prefix argument, it will narrow to view only that output.
   - ~C-c C-o~ will delete the output from the last command.
   - ~C-c C-f~ will move forward a complete shell argument.
   - ~C-c C-b~ will move backward a complete shell argument.
** Configuration
Scrolling through the output and searching for results that can be copied to the kill ring is a great feature of Eshell. However, instead of running =end-of-buffer= key-binding, the following setting means any other key will jump back to the prompt:
  #+BEGIN_SRC emacs-lisp
    (use-package eshell
      :init
      (setq ;; eshell-buffer-shorthand t ...  Can't see Bug#19391
            eshell-scroll-to-bottom-on-input 'all
            eshell-error-if-no-glob t
            eshell-hist-ignoredups t
            eshell-save-history-on-exit t
            eshell-prefer-lisp-functions nil
            eshell-destroy-buffer-when-process-dies t))
  #+END_SRC
   I can never seem to remember that =find= and =chmod= behave differently from Emacs than their Unix counterparts, so the last setting will prefer the native implementations.
** Visual Executables
  Eshell would get somewhat confused if I ran the following commands directly through the normal Emacs-Lisp library, as these need the better handling of ansiterm:
  #+BEGIN_SRC emacs-lisp
    (use-package eshell
      :init
      (add-hook 'eshell-mode-hook
                (lambda ()
                  (add-to-list 'eshell-visual-commands "ssh")
                  (add-to-list 'eshell-visual-commands "tail")
                  (add-to-list 'eshell-visual-commands "top"))))
  #+END_SRC
** Aliases
  Gotta have some [[http://www.emacswiki.org/emacs/EshellAlias][shell aliases]], right?
  #+BEGIN_SRC emacs-lisp
      (add-hook 'eshell-mode-hook (lambda ()
          (eshell/alias "e" "find-file $1")
          (eshell/alias "ff" "find-file $1")
          (eshell/alias "emacs" "find-file $1")
          (eshell/alias "ee" "find-file-other-window $1")

          (eshell/alias "gd" "magit-diff-unstaged")
          (eshell/alias "gds" "magit-diff-staged")
          (eshell/alias "d" "dired $1")

          ;; The 'ls' executable requires the Gnu version on the Mac
          (let ((ls (if (file-exists-p "/usr/local/bin/gls")
                        "/usr/local/bin/gls"
                      "/bin/ls")))
            (eshell/alias "ll" (concat ls " -AlohG --color=always")))))
  #+END_SRC
** Git
My =gst= command is just an alias to =magit-status=, but using the =alias= doesn't pull in the current working directory, so I make it a function, instead:
   #+BEGIN_SRC emacs-lisp
     (defun eshell/gst (&rest args)
         (magit-status (pop args) nil)
         (eshell/echo))   ;; The echo command suppresses output
   #+END_SRC
** Find File
   We should have an "f" alias for searching the current directory for a file, and a "ef" for editing that file.
   #+BEGIN_SRC emacs-lisp
     (defun eshell/f (filename &optional dir try-count)
       "Searches for files matching FILENAME in either DIR or the
     current directory. Just a typical wrapper around the standard
     `find' executable.

     Since any wildcards in FILENAME need to be escaped, this wraps the shell command.

     If not results were found, it calls the `find' executable up to
     two more times, wrapping the FILENAME pattern in wildcat
     matches. This seems to be more helpful to me."
       (let* ((cmd (concat
                    (executable-find "find")
                    " " (or dir ".")
                    "      -not -path '*/.git*'"
                    " -and -not -path '*node_modules*'"
                    " -and -not -path '*classes*'"
                    " -and "
                    " -type f -and "
                    "-iname '" filename "'"))
              (results (shell-command-to-string cmd)))

         (if (not (s-blank-str? results))
             results
           (cond
            ((or (null try-count) (= 0 try-count))
             (eshell/f (concat filename "*") dir 1))
            ((or (null try-count) (= 1 try-count))
             (eshell/f (concat "*" filename) dir 2))
            (t "")))))

     (defun eshell/ef (filename &optional dir)
       "Searches for the first matching filename and loads it into a
     file to edit."
       (let* ((files (eshell/f filename dir))
              (file (car (s-split "\n" files))))
         (find-file file)))
   #+END_SRC
   Typing =find= in Eshell runs the =find= function, which doesn’t do what I expect, and creating an alias is ineffective in overriding it, so a function will do:
   #+BEGIN_SRC emacs-lisp
     (defun eshell/find (&rest args)
       "Wrapper around the ‘find’ executable."
       (let ((cmd (concat "find " (string-join args))))
         (shell-command-to-string cmd)))
   #+END_SRC
** Clear

   While deleting and recreating =eshell= may be just as fast, I always
   forget and type =clear=, so let's implement it:

   #+BEGIN_SRC emacs-lisp
     (defun eshell/clear ()
       "Clear the eshell buffer."
       (let ((inhibit-read-only t))
         (erase-buffer)
         (eshell-send-input)))
   #+END_SRC

** Predicate Filters and Modifiers
  The =T= predicate filter allows me to limit file results that have have internal =org-mode= tags. For instance, files that have a =#+TAGS:= header with a =mac= label will be given to the =grep= function:
  #+BEGIN_SRC sh
     $ grep brew *.org(T'mac')
  #+END_SRC
  To extend Eshell, we need a two-part function.
  1. Parse the Eshell buffer to look for the parameter (and move the point past the parameter).
  2. A predicate function that takes a file as a parameter.

  For the first step, we have our function /called/ as it helps parse the text at this time. Based on what it sees, it returns the predicate function used to filter the files:
  #+BEGIN_SRC emacs-lisp
    (defun eshell-org-file-tags ()
      "Helps the eshell parse the text the point is currently on,
    looking for parameters surrounded in single quotes. Returns a
    function that takes a FILE and returns nil if the file given to
    it doesn't contain the org-mode #+TAGS: entry specified."

      (if (looking-at "'\\([^)']+\\)'")
          (let* ((tag (match-string 1))
                 (reg (concat "^#\\+TAGS:.* " tag "\\b")))
            (goto-char (match-end 0))

            `(lambda (file)
               (with-temp-buffer
                 (insert-file-contents file)
                 (re-search-forward ,reg nil t 1))))
        (error "The `T' predicate takes an org-mode tag value in single quotes.")))
  #+END_SRC

  Add it to the =eshell-predicate-alist= as the =T= tag:
  #+BEGIN_SRC emacs-lisp
    (add-hook 'eshell-pred-load-hook (lambda ()
      (add-to-list 'eshell-predicate-alist '(?T . (eshell-org-file-tags)))))
  #+END_SRC
  *Note:* We can’t add it to the list until after we start our first
  eshell session, so we just add it to the =eshell-pred-load-hook=
  which is sufficient.
** Special Prompt

  Following [[http://blog.liangzan.net/blog/2012/12/12/customizing-your-emacs-eshell-prompt/][these instructions]], we build a better prompt with the Git
  branch in it (Of course, it matches my Bash prompt). First, we need
  a function that returns a string with the Git branch in it,
  e.g. ":master"

  #+BEGIN_SRC emacs-lisp
    (defun curr-dir-git-branch-string (pwd)
      "Returns current git branch as a string, or the empty string if
    PWD is not in a git repo (or the git command is not found)."
      (interactive)
      (when (and (not (file-remote-p pwd))
                 (eshell-search-path "git")
                 (locate-dominating-file pwd ".git"))
        (let* ((git-url (shell-command-to-string "git config --get remote.origin.url"))
               (git-repo (file-name-base (s-trim git-url)))
               (git-output (shell-command-to-string (concat "git rev-parse --abbrev-ref HEAD")))
               (git-branch (s-trim git-output))
               (git-icon  "\xe0a0")
               (git-icon2 (propertize "\xf020" 'face `(:family "octicons"))))
          (concat git-repo " " git-icon2 " " git-branch))))
  #+END_SRC

  The function takes the current directory passed in via =pwd= and
  replaces the =$HOME= part with a tilde. I'm sure this function
  already exists in the eshell source, but I didn't find it...

  #+BEGIN_SRC emacs-lisp
    (defun pwd-replace-home (pwd)
      "Replace home in PWD with tilde (~) character."
      (interactive)
      (let* ((home (expand-file-name (getenv "HOME")))
             (home-len (length home)))
        (if (and
             (>= (length pwd) home-len)
             (equal home (substring pwd 0 home-len)))
            (concat "~" (substring pwd home-len))
          pwd)))
  #+END_SRC

  Make the directory name be shorter...by replacing all directory
  names with just its first names. However, we leave the last two to
  be the full names. Why yes, I did steal this.

  #+BEGIN_SRC emacs-lisp
    (defun pwd-shorten-dirs (pwd)
      "Shorten all directory names in PWD except the last two."
      (let ((p-lst (split-string pwd "/")))
        (if (> (length p-lst) 2)
            (concat
             (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                   (substring elm 0 1)))
                        (butlast p-lst 2)
                        "/")
             "/"
             (mapconcat (lambda (elm) elm)
                        (last p-lst 2)
                        "/"))
          pwd)))  ;; Otherwise, we just return the PWD
  #+END_SRC

  Break up the directory into a "parent" and a "base":

  #+BEGIN_SRC emacs-lisp
    (defun split-directory-prompt (directory)
      (if (string-match-p ".*/.*" directory)
          (list (file-name-directory directory) (file-name-base directory))
        (list "" directory)))
  #+END_SRC

  Using virtual environments for certain languages is helpful to know,
  especially since I change them based on the directory.

  #+BEGIN_SRC emacs-lisp
    (defun ruby-prompt ()
      "Returns a string (may be empty) based on the current Ruby Virtual Environment."
      (let* ((executable "~/.rvm/bin/rvm-prompt")
             (command    (concat executable "v g")))
        (when (file-exists-p executable)
          (let* ((results (shell-command-to-string executable))
                 (cleaned (string-trim results))
                 (gem     (propertize "\xe92b" 'face `(:family "alltheicons"))))
            (when (and cleaned (not (equal cleaned "")))
              (s-replace "ruby-" gem cleaned))))))

    (defun python-prompt ()
      "Returns a string (may be empty) based on the current Python
       Virtual Environment. Assuming the M-x command: `pyenv-mode-set'
       has been called."
      (when (fboundp #'pyenv-mode-version)
        (let ((venv (pyenv-mode-version)))
          (when venv
            (concat
             (propertize "\xe928" 'face `(:family "alltheicons"))
             (pyenv-mode-version))))))
  #+END_SRC

  Now tie it all together with a prompt function can color each of the
  prompts components.

  #+BEGIN_SRC emacs-lisp
    (defun eshell/eshell-local-prompt-function ()
      "A prompt for eshell that works locally (in that is assumes
    that it could run certain commands) in order to make a prettier,
    more-helpful local prompt."
      (interactive)
      (let* ((pwd        (eshell/pwd))
             (directory (split-directory-prompt
                         (pwd-shorten-dirs
                          (pwd-replace-home pwd))))
             (parent (car directory))
             (name   (cadr directory))
             (branch (curr-dir-git-branch-string pwd))
             (ruby   (when (not (file-remote-p pwd)) (ruby-prompt)))
             (python (when (not (file-remote-p pwd)) (python-prompt)))

             (dark-env (eq 'dark (frame-parameter nil 'background-mode)))
             (for-bars                 `(:weight bold))
             (for-parent  (if dark-env `(:foreground "dark orange") `(:foreground "blue")))
             (for-dir     (if dark-env `(:foreground "orange" :weight bold)
                            `(:foreground "blue" :weight bold)))
             (for-git                  `(:foreground "green"))
             (for-ruby                 `(:foreground "red"))
             (for-python               `(:foreground "#5555FF")))

        (concat
         (propertize "⟣─ "    'face for-bars)
         (propertize parent   'face for-parent)
         (propertize name     'face for-dir)
         (when branch
           (concat (propertize " ── "    'face for-bars)
                   (propertize branch   'face for-git)))
         (when ruby
           (concat (propertize " ── " 'face for-bars)
                   (propertize ruby   'face for-ruby)))
         (when python
           (concat (propertize " ── " 'face for-bars)
                   (propertize python 'face for-python)))
         (propertize "\n"     'face for-bars)
         (propertize (if (= (user-uid) 0) " #" " $") 'face `(:weight ultra-bold))
         ;; (propertize " └→" 'face (if (= (user-uid) 0) `(:weight ultra-bold :foreground "red") `(:weight ultra-bold)))
         (propertize " "    'face `(:weight bold)))))

    (setq-default eshell-prompt-function #'eshell/eshell-local-prompt-function)
  #+END_SRC

  Turn off the default prompt, otherwise, it won't use ours:

  #+BEGIN_SRC emacs-lisp
    (setq eshell-highlight-prompt nil)
  #+END_SRC

  Here is the result:
  [[http://imgur.com/nkpwII0.png]]

** Shell Windows

  Now that I often need to quickly pop into remote systems to run a
  shell or commands, I create helper functions to create those buffer
  windows.  Each begin with =eshell-=:

*** Shell Here

   Making little Shells whenever I need them:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun eshell-here ()
       "Opens up a new shell in the directory associated with the
     current buffer's file. The eshell is renamed to match that
     directory to make multiple eshell windows easier."
       (interactive)
       (let* ((parent (if (buffer-file-name)
                          (file-name-directory (buffer-file-name))
                        default-directory))
              (height (/ (window-total-height) 3))
              (name   (car (last (split-string parent "/" t)))))
         (split-window-vertically (- height))
         (other-window 1)
         (eshell "new")
         (rename-buffer (concat "*eshell: " name "*"))

         (insert (concat "ls"))
         (eshell-send-input)))

     (bind-key "C-!" 'eshell-here)
   #+END_SRC

   Let's try a version that doesn't put the current working directory
   in the mode-line's buffer title:

   #+BEGIN_SRC emacs-lisp
     (defun eshell-here ()
       "Opens up a new shell in the directory associated with the
         current buffer's file. The eshell is renamed to match that
         directory to make multiple eshell windows easier."
       (interactive)
       (let* ((height (/ (window-total-height) 3)))
         (split-window-vertically (- height))
         (other-window 1)
         (eshell "new")
         (insert (concat "ls"))
         (eshell-send-input)))

     (bind-key "C-!" 'eshell-here)
   #+END_SRC

   Used to ~C-d~ exiting from a shell? Want it to keep working, but still
   allow deleting a character? We can have it both (thanks to [[https://github.com/wasamasa/dotemacs/blob/master/init.org#eshell][wasamasa]]):

   #+BEGIN_SRC emacs-lisp
     (use-package eshell
       :config
       (defun ha/eshell-quit-or-delete-char (arg)
         (interactive "p")
         (if (and (eolp) (looking-back eshell-prompt-regexp))
             (progn
               (eshell-life-is-too-much) ; Why not? (eshell/exit)
               (ignore-errors
                 (delete-window)))
           (delete-forward-char arg)))
       :init
       (add-hook 'eshell-mode-hook
                 (lambda ()
                   (bind-keys :map eshell-mode-map
                              ("C-d" . ha/eshell-quit-or-delete-char)))))
   #+END_SRC

*** Shell There
   :PROPERTIES:
   :CUSTOM_ID: remote-shell
   :END:

   Would be nice to be able to run an eshell session and use Tramp to
   connect to the remote host in one fell swoop:

   #+BEGIN_SRC emacs-lisp
     (defun eshell-there (host)
       "Creates an eshell session that uses Tramp to automatically
     connect to a remote system, HOST.  The hostname can be either the
     IP address, or FQDN, and can specify the user account, as in
     root@blah.com. HOST can also be a complete Tramp reference."
       (interactive "sHost: ")

       (let* ((default-directory
                (cond
                 ((string-match-p "^/" host) host)

                 ((string-match-p (ha/eshell-host-regexp 'full) host)
                  (string-match (ha/eshell-host-regexp 'full) host) ;; Why!?
                  (let* ((user1 (match-string 2 host))
                         (host1 (match-string 3 host))
                         (user2 (match-string 6 host))
                         (host2 (match-string 7 host)))
                    (if host1
                        (ha/eshell-host->tramp user1 host1)
                      (ha/eshell-host->tramp user2 host2))))

                 (t (format "/%s:" host)))))
         (eshell-here)))
   #+END_SRC

   Note that this function uses functions defined below.

*** Shell Here to There

   Since I have Org files that contains tables of system to remotely
   connect to, I figured I should have a little function that can jump
   to a host found listed anywhere on the line.

   The regular expression associated with IP addresses, hostnames, user
   accounts (of the form, =jenkins@my.build.server=, or even full Tramp
   references, is a bit...uhm, hairy.  And since I want to reuse these,
   I will hide them in a function:

   #+BEGIN_SRC emacs-lisp
     (defun ha/eshell-host-regexp (regexp)
       "Returns a particular regular expression based on symbol, REGEXP"
       (let* ((user-regexp      "\\(\\([[:alpha:].]+\\)@\\)?")
              (tramp-regexp     "\\b/ssh:[:graph:]+")
              (ip-char          "[[:digit:]]")
              (ip-plus-period   (concat ip-char "+" "\\."))
              (ip-regexp        (concat "\\(\\(" ip-plus-period "\\)\\{3\\}" ip-char "+\\)"))
              (host-char        "[[:alpha:][:digit:]-]")
              (host-plus-period (concat host-char "+" "\\."))
              (host-regexp      (concat "\\(\\(" host-plus-period "\\)+" host-char "+\\)"))
              (horrific-regexp  (concat "\\b"
                                        user-regexp ip-regexp
                                        "\\|"
                                        user-regexp host-regexp
                                        "\\b")))
         (cond
          ((eq regexp 'tramp) tramp-regexp)
          ((eq regexp 'host)  host-regexp)
          ((eq regexp 'full)  horrific-regexp))))
   #+END_SRC

   The function to scan a line for hostname patterns uses different
   function calls that what I could use for =eshell-there=, so let's
   =save-excursion= and hunt around:

   #+BEGIN_SRC emacs-lisp
     (defun ha/eshell-scan-for-hostnames ()
       "Helper function to scan the current line for any hostnames, IP
     or Tramp references.  This returns a tuple of the username (if
     found) and the hostname.

     If a Tramp reference is found, the username part of the tuple
     will be `nil'."
       (save-excursion
         (goto-char (line-beginning-position))
         (if (search-forward-regexp (ha/eshell-host-regexp 'tramp) (line-end-position) t)
             (cons nil (buffer-substring-no-properties (match-beginning 0) (match-end 0)))

           ;; Returns the text associated with match expression, NUM or `nil' if no match was found.
           (cl-flet ((ha/eshell-get-expression (num) (if-let ((first (match-beginning num))
                                                              (end   (match-end num)))
                                                         (buffer-substring-no-properties first end))))

             (search-forward-regexp (ha/eshell-host-regexp 'full) (line-end-position))

             ;; Until this is completely robust, let's keep this debugging code here:
             ;; (message (mapconcat (lambda (tup) (if-let ((s (car tup))
             ;;                                       (e (cadr tup)))
             ;;                                  (buffer-substring-no-properties s e)
             ;;                                "null"))
             ;;             (-partition 2 (match-data t)) " -- "))

             (let ((user1 (ha/eshell-get-expression 2))
                   (host1 (ha/eshell-get-expression 3))
                   (user2 (ha/eshell-get-expression 6))
                   (host2 (ha/eshell-get-expression 7)))
               (if host1
                   (cons user1 host1)
                 (cons user2 host2)))))))
   #+END_SRC

   Tramp reference can be long when attempting to connect as another
   user account using the pipe symbol.

   #+BEGIN_SRC emacs-lisp
     (defun ha/eshell-host->tramp (username hostname &optional prefer-root)
       "Returns a TRAMP reference based on a USERNAME and HOSTNAME
     that refers to any host or IP address."
       (cond ((string-match-p "^/" host)
                host)
             ((or (and prefer-root (not username)) (equal username "root"))
                (format "/ssh:%s|sudo:%s:" hostname hostname))
             ((or (null username) (equal username user-login-name))
                (format "/ssh:%s:" hostname))
             (t
                (format "/ssh:%s|sudo:%s|sudo@%s:%s:" hostname hostname username hostname))))
   #+END_SRC

   Finally
   #+BEGIN_SRC emacs-lisp
     (defun eshell-here-on-line (p)
       "Search the current line for an IP address or hostname, and call the `eshell-here' function.

     Call with PREFIX to connect with the `root' useraccount, via
     `sudo'."
       (interactive "p")
       (destructuring-bind (user host) (ha/eshell-scan-for-hostnames)
         (let ((default-directory (ha/eshell-host->tramp user host (> p 1))))
           (message "Connecting to: %s" default-directory)
           ;; With the `default-directory' set to a Tramp reference, rock on!
           (eshell-here))))

     (bind-key "M-s-1" #'eshell-here-on-line)
   #+END_SRC

*** Shell Favorites

    Since the Tramp syntax is a bit verbose, a few /wrapper functions/
    would make things easier. Also, having a list of /favorite hosts/
    with simpler names would also be a nice feature.

    Since Emacs doesn't have a memoize function, define a global
    variable, =remote-shell-fav-hosts=, a hash that maps nicknames of
    hosts to their IP address.

    #+BEGIN_SRC emacs-lisp
     (defvar remote-shell-fav-hosts (make-hash-table :test 'equal)
       "Table of host aliases for IPs or other actual references.")
    #+END_SRC

    Can we make a list of what hosts are /pre-known/? What if no hosts
    have been defined? In this case, we want to call the function,
    =remote-shell-fav-hosts-get= to populate it:

    #+BEGIN_SRC emacs-lisp
      (defun remote-shell-fav-hosts-map ()
        "Returns the mapping between our simple names of our favorite
      hosts and their IP address. If the map is empty, and the function
      `remote-shell-fav-hosts-get' has been defined, it calls that
      function to populate the map prior to returning it. This may
      return an empty map."
        (when (and #'remote-shell-fav-hosts-get
                   (hash-table-empty-p remote-shell-fav-hosts))
          (remote-shell-fav-hosts-get))
        remote-shell-fav-hosts)
    #+END_SRC

    In order to populate the =completing-read=, we need a list of hosts:

    #+BEGIN_SRC emacs-lisp
      (defun remote-shell-fav-hosts-list ()
        "Simply returns a list of known hosts from the cached map, or
      populates it first if it is empty and the
      `remote-shell-fav-hosts-get' function has been defined."
        (hash-table-keys (remote-shell-fav-hosts-map)))
    #+END_SRC

    Most remote access is done with Tramp, so this function simplifies
    the complex Tramp string creation, mostly using an =sudo= pipe for
    =root= access. If the =remote-shell-fav-hosts= hash is empty, we'll
    populate it when this is called.

    #+BEGIN_SRC emacs-lisp
      (defun remote-shell-tramp-connection (hostname &optional root directory)
        "Return a TRAMP connection string to HOSTNAME. If ROOT is
      non-nil, returns an sudo compatible string."
        (when (null directory)
          (setq directory ""))

        ;; The ip address is either the value from a key in our cache, or whatever we pass in:
        (let ((ipaddr (gethash hostname (remote-shell-fav-hosts-map) hostname)))
          (if root
              (format "/ssh:%s|sudo:%s:%s" ipaddr ipaddr directory)
              (format "/ssh:%s:%s"         ipaddr directory))))
    #+END_SRC

    If the window containing the results of the shell connection or
    shell command is the same, we can take advantage of that from
    multiple functions, so:

    #+BEGIN_SRC emacs-lisp
      (defun remote-shell-buffer-name (hostname &optional command-str default-name)
        "Returns a standard format for our remote shell command buffer
      windows based on the HOSTNAME and the COMMAND-STR. Uses
      DEFAULT-NAME if specified."
        (cond
         (default-name     default-name)
         (command-str      (let ((command (car (split-string command-str))))
                              (format "*%s:%s*" hostname command)))
         (t                (format "*%s*" hostname))))
    #+END_SRC

    Our simple wrapper function for accessing a remote shell, should
    use =ido= if available.

    #+BEGIN_SRC emacs-lisp
      (defun remote-shell (hostname &optional root)
        "Start an shell experience on HOSTNAME, that can be an alias to
      a virtual machine from my 'cloud' server. With prefix command, opens
      the shell as the root user account."
        (interactive
         (list (if (fboundp #'ido-completing-read)
                   (ido-completing-read "Hostname: " (remote-shell-fav-hosts-list))
                 (completing-read "Hostname: " (remote-shell-fav-hosts-list)))))
        (when (equal current-prefix-arg '(4))
          (setq root t))
        (let ((default-directory (remote-shell-tramp-connection hostname root)))
          (shell (remote-shell-buffer-name hostname))))
    #+END_SRC

    With the way Emacs Lisp's =interactive= behaves, I'm not sure how to
    DRY this function to be a simple alias with the exception of
    using eshell:

    #+BEGIN_SRC emacs-lisp
      (defun eshell-favorite (hostname &optional root)
        "Start an shell experience on HOSTNAME, that can be an alias to
      a virtual machine from my 'cloud' server. With prefix command, opens
      the shell as the root user account."
        (interactive
         (list (if (fboundp #'ido-completing-read)
                   (ido-completing-read "Hostname: " (remote-shell-fav-hosts-list))
                 (completing-read "Hostname: " (remote-shell-fav-hosts-list)))))
        (when (equal current-prefix-arg '(4))
          (setq root t))
        (let ((default-directory (remote-shell-tramp-connection hostname root)))
          (eshell (remote-shell-buffer-name hostname))))
    #+END_SRC

    Instead of starting a shell, what if we just ran a command using the
    =shell-command= (so that commands that end in a =&= are automatically
    ran asynchronously.

    #+BEGIN_SRC emacs-lisp
      (defun remote-shell-command (hostname command
                                            &optional root bufname directory)
        "On HOSTNAME, run COMMAND (if the command ends with &, run
      asynchronously). With a `C-u' prefix, run the command as ROOT.
      When non-interactive, you can specify BUFNAME for the buffer's
      name, and DIRECTORY where the command should run."
        (interactive
         (list (if #'ido-completing-read
                   (ido-completing-read "Hostname: " (remote-shell-fav-hosts-list))
                 (completing-read "Hostname: " (remote-shell-fav-hosts-list)))
               (read-string "Command: ")))
        (when (equal current-prefix-arg '(4))
          (setq root t))
        (let ((default-directory (remote-shell-tramp-connection hostname root directory)))
          (shell-command command (remote-shell-buffer-name hostname command bufname))))
    #+END_SRC

    With the above helper functions, we can loop over a list of machines,
    and kick off remote work on each one:

    #+BEGIN_SRC emacs-lisp
      (defun remote-shell-commands (clients command
                                            &optional root async directory)
        "On each host entry in CLIENTS, run the shell COMMAND,
      optionally as ROOT. If ASYNC is non-nil, appends the `&' to the
      shell command in order to run it asynchronously. Runs the command
      in the default home directory unless DIRECTORY is specified."
        (if async
            (setq command (concat command " &")))
        (dolist (host clients)
          (remote-shell-command host command root nil directory)))
    #+END_SRC

    The results of each command is stored in a separate buffer, and
    since we know what the names are, this command will attempt to load
    them on the side... yeah, this is a bit ugly.

    #+BEGIN_SRC emacs-lisp
      (defun remote-shell-commands-show (clients command)
        "Shows each buffer of a previously executed command. For example:

              (let ((my-favs '(\"os-controller\" \"contrail-controller\"
                               \"compute\" \"nagios\" \"elk\"))
                    (command \"chef-client\"))
                (remote-shell-commands my-favs command t t)
                (remote-shell-commands-show my-favs command))"

        (delete-other-windows)
        (let ((first-time t))
          (dolist (host clients)
            (if (not first-time)
                (split-window-vertically)
              (split-window-horizontally)
              (setq first-time nil))

            (other-window 1)
            (switch-to-buffer (remote-shell-buffer-name host command))
            (balance-windows)
            (sit-for 0.5))))
    #+END_SRC

    All this work allows me to do magic:

    #+BEGIN_SRC emacs-lisp :tangle no
      (let ((my-favs '("os-controller" "contrail-controller"
                       "compute" "nagios" "elk"))
            (command "chef-client"))
        (remote-shell-commands my-favs command t t)
        (remote-shell-commands-show my-favs command))
    #+END_SRC

    Check out this [[https://www.youtube.com/watch?v=pSjrwSI4OHk][YouTube video recording]] of this section in action.

** Tramp

  The ability to edit files on remote systems is a wonderful win,
  since it means I don't need to have my Emacs environment running on
  remote machines (still a possibility, just not a requirement).

  According to [[http://www.gnu.org/software/emacs/manual/html_node/tramp/Filename-Syntax.html][the manual]], I can access a file over SSH, via:

  #+BEGIN_EXAMPLE
  /ssh:10.52.224.67:blah
  #+END_EXAMPLE

  However, if I set the default method to SSH, I can do this:

  #+BEGIN_EXAMPLE
  /10.52.224.67:blah
  #+END_EXAMPLE

  So, let's do it...

  #+BEGIN_SRC emacs-lisp
    (setq tramp-default-method "ssh")
  #+END_SRC

** Better Command Line History

  On [[http://www.reddit.com/r/emacs/comments/1zkj2d/advanced_usage_of_eshell/][this discussion]] a little gem for using IDO to search back through
  the history, instead of =M-R= to display the history in a selectable
  buffer.

  Also, while =M-p= cycles through the history, =M-P= actually moves
  up the history in the buffer (easier than =C-c p= and =C-c n=?):

  Since eshell's history often gets confused with blank lines in the
  output, we can fix that with a better replacement functions pegged
  to the =eshell-prompt-regexp= string:

  #+BEGIN_SRC emacs-lisp
      (defun eshell-next-prompt (n)
        "Move to end of Nth next prompt in the buffer. See `eshell-prompt-regexp'."
        (interactive "p")
        (re-search-forward eshell-prompt-regexp nil t n)
        (when eshell-highlight-prompt
          (while (not (get-text-property (line-beginning-position) 'read-only) )
            (re-search-forward eshell-prompt-regexp nil t n)))
        (eshell-skip-prompt))

      (defun eshell-previous-prompt (n)
        "Move to end of Nth previous prompt in the buffer. See `eshell-prompt-regexp'."
        (interactive "p")
        (backward-char)
        (eshell-next-prompt (- n)))

      (defun eshell-insert-history ()
        "Displays the eshell history to select and insert back into your eshell."
        (interactive)
        (insert (ido-completing-read "Eshell history: "
                                     (delete-dups
                                      (ring-elements eshell-history-ring)))))

      (add-hook 'eshell-mode-hook (lambda ()
          (define-key eshell-mode-map (kbd "M-S-P") 'eshell-previous-prompt)
          (define-key eshell-mode-map (kbd "M-S-N") 'eshell-next-prompt)
          (define-key eshell-mode-map (kbd "M-r") 'eshell-insert-history)))
  #+END_SRC

** Helpers

  Sometimes you just need to change something about the current file
  you are editing...like the permissions or even execute it. Hitting
  =Command-1= will prompt for a shell command string and then append
  the current file to it and execute it.

  #+BEGIN_SRC emacs-lisp
    (defun execute-command-on-file-buffer (cmd)
      (interactive "sCommand to execute: ")
      (let* ((file-name (buffer-file-name))
             (full-cmd (concat cmd " " file-name)))
        (shell-command full-cmd)))

    (bind-key "A-1" #'execute-command-on-file-buffer)

    (defun execute-command-on-file-directory (cmd)
      (interactive "sCommand to execute: ")
      (let* ((dir-name (file-name-directory (buffer-file-name)))
             (full-cmd (concat "cd " dir-name "; " cmd)))
        (shell-command full-cmd)))

    (bind-key "A-!" #'execute-command-on-file-directory)
    (bind-key "s-!" #'execute-command-on-file-directory)
  #+END_SRC

  Some prompts, shells and terminal programs that display the exit
  code as an icon in the fringe. So can the [[http://projects.ryuslash.org/eshell-fringe-status/][eshell-fringe-status]]
  project. Seems to me, that if would be useful to rejuggle those
  fringe markers so that the marker matched the command entered
  (instead of seeing a red mark, and needing to scroll back in order
  to wonder what command it was that made it). Still...

  #+BEGIN_SRC emacs-lisp
  (use-package eshell-fringe-status
    :config
    (add-hook 'eshell-mode-hook 'eshell-fringe-status-mode))
  #+END_SRC

* auto-complete
  - Lets you use the auto-complete package
    #+BEGIN_SRC emacs-lisp
     (use-package auto-complete
     :ensure t)
     (require 'auto-complete)
     (require 'auto-complete-config)
     (global-auto-complete-mode t)
     (add-to-list 'ac-modes 'org-mode)
     (ac-config-default)
    #+END_SRC
* Company Mode
Company is a text completion framework for Emacs. The name stands for "complete anything". It uses pluggable back-ends and front-ends to retrieve and display completion candidates.
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (setq company-idle-delay 0)
  (setq company-minimum-prefix-length 3))
;;To use company-mode in all buffers
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC
* Spell check
#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "/usr/bin/aspell")
(setq ispell-dictionary "english")
#+END_SRC
* Web Development
I do quite a bit of web-development and have snippets, automatic indentation and autocompletion is a big help . =web-mode.el= is an autonomous emacs major-mode for editing web templates. It also takes care of basic stuff like syntax highlighting, auto pairing tags, removing white spaces etc. Web-mode is feature rich and as extensible as Emacs itself. For more details visit this [[http://web-mode.org/][link]]
#+BEGIN_SRC emacs-lisp
(use-package web-mode
:ensure t)

;;Automatically load web-mode when opening web-related files
(add-to-list 'auto-mode-alist '("\\.ts\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.css?\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.js\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))

(setq web-mode-engines-alist
      '(("php"    . "\\.phtml\\'")
        ("blade"  . "\\.blade\\.")))

;;Set indentations
(defun my-web-mode-hook ()
"Hooks for Web mode."
(setq web-mode-markup-indent-offset 2)
(setq web-mode-code-indent-offset 2)
(setq web-mode-css-indent-offset 2))
(add-hook 'web-mode-hook  'my-web-mode-hook)    
(setq tab-width 2)

;;Highlight of columns
(setq web-mode-enable-current-column-highlight t)
(setq web-mode-enable-current-element-highlight t)

;;Autoremove final white spaces on save
(add-hook 'local-write-file-hooks
            (lambda ()
               (delete-trailing-whitespace)
               nil))
#+END_SRC

*** Emmet Mode
Emmet (formerly *Zen Coding*) is a web-developer’s toolkit that can greatly improve your HTML & CSS workflow.

With Emmet, you can type CSS-like expressions that can be dynamically parsed, and produce output depending on what you type in the abbreviation. Emmet is developed and optimised for web-developers whose workflow depends on HTML/XML and CSS, but can be used with programming languages too.

For example, this abbreviation:
#+BEGIN_SRC html
 ul#nav>li.item$*4>a{Item $}
#+END_SRC
...can be expanded into:
#+BEGIN_SRC html
	<ul id="nav">
		<li class="item1"><a href="">Item 1</a></li>
		<li class="item2"><a href="">Item 2</a></li>
		<li class="item3"><a href="">Item 3</a></li>
		<li class="item4"><a href="">Item 4</a></li>
	</ul>
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
:ensure t)
;;Turn on Emmet in web-mode.
(add-hook 'web-mode-hook  'emmet-mode) 

;;Web-mode is able to switch modes into css (style tags) or js (script tags) in an html file. For Emmet to switch between html and css properly in the same document, this hook is added.
 (add-hook 'web-mode-before-auto-complete-hooks
   '(lambda ()
    (let ((web-mode-cur-language
 	    (web-mode-language-at-pos)))
              (if (string= web-mode-cur-language "php")
   	   (yas-activate-extra-mode 'php-mode)
     	 (yas-deactivate-extra-mode 'php-mode))
              (if (string= web-mode-cur-language "css")
   	   (setq emmet-use-css-transform t)
     	 (setq emmet-use-css-transform nil)))))

#+END_SRC
*** Rainbow
Mostly useful if you are into web development or game development. Every time emacs encounters a hexadecimal code that resembles a color, it will automatically highlight it in the appropriate color. This is a lot cooler than you may think.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init
      (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC
* Brackets using electric
If you write any code, you may enjoy this. Typing the first character in a set of 2, completes the second one after your cursor. Opening a bracket? It’s closed for you already. Quoting something? It’s closed for you already. You can easily add and remove pairs yourself, have a look.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs '(
                           (?\{ . ?\})
                           (?\( . ?\))
                           (?\[ . ?\])
                           (?\" . ?\")
                           ))
(electric-pair-mode t)
#+END_SRC
* Semantic Selection
So what this package does is it select text in way that's sensibe towards the syntax. So for example if I'm in a html tag that is the child of another tag, invoking the keybinding for this package will first select the child then the parent and hierarchichally move upwards. No need to drag the mouse around, this is selection done sensibly.
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind ("C-=" . er/expand-region))
#+END_SRC
* Snippets
Unlike autocomplete which suggests words / symbols, snippets are pre-prepared templates which you fill in. I'm using a community library (=[[https://github.com/AndreaCrotti/yasnippet-snippets]]=) with *lots* of ready made options, and have my own directory of custom snippets I've added. Not sure if I should unify these by forking =yasnippet-snippets=. Type the shortcut and press =TAB= to complete, or =M-/= to autosuggest a snippet.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
:ensure t
:diminish yas-minor-mode
:config
(use-package yasnippet-snippets
:ensure t)
(yas-reload-all)
(add-to-list 'yas-snippet-dirs "~/.emacs.d/yasnippet-snippets")
(add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
(yas-global-mode))
(add-to-list 'auto-mode-alist '("\\.c\\'" . web-mode))
#+END_SRC
* lorem Ipsum
Inserts lorem ipsum text in your emacs buffer. This text has been used since the 16th Century as a dummy text when you are preparing the layout of some presentation but don’t have the final text yet, or want to demonstrate the layout without distracting the reader with actual content. The lorem ipsum text originated from “de Finibus Bonorum et Malorum” (The Extremes of Good and Evil) by Marcus Tullius Cicero, written in 45 BC but it has been so transformed along the years that now, it is relatively meaningless.
Three functions are available:
- Lorem-ipsum-insert-paragraphs
- Lorem-ipsum-insert-sentences
- Lorem-ipsum-insert-list
#+BEGIN_SRC emacs-lisp
(use-package lorem-ipsum
:ensure t)
(require 'lorem-ipsum)
(global-set-key (kbd "C-; s") 'lorem-ipsum-insert-sentences)
(global-set-key (kbd "C-; p") 'lorem-ipsum-insert-paragraphs)
(global-set-key (kbd "C-; l") 'lorem-ipsum-insert-list)
#+END_SRC
* Multiple Cursors
Multiple cursors for Emacs. Multiple cursors is a very nice package that lets you create several cursors that all do the same thing as you type (see the example below). You can add it to emacs using the steps described here Once you have installed it, it is useful to set up a keybinding (a keyboard short-cut) for it. You can do this by adding the following to your emacs config file to set C-c m c as the binding for multiple cursors. 
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
:ensure t)
(require 'multiple-cursors)
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
#+END_SRC
* Project Management
*Projectile* is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a project level without introducing external dependencies (when feasible). For instance - finding project files has a portable implementation written in pure Emacs Lisp without the use of GNU find (but for performance sake an indexing mechanism backed by external commands exists as well).

Projectile tries to be practical - portability is great, but if some external tools could speed up some task substantially and the tools are available, Projectile will leverage them
#+BEGIN_SRC emacs-lisp
(use-package projectile
:ensure t
  :init
  (projectile-mode 1))
#+END_SRC
* Version Control
*** Magit
Magit is an interface to the version control system Git, implemented as an Emacs package. Magit aspires to be a complete Git porcelain. While we cannot (yet) claim that Magit wraps and improves upon each and every Git command, it is complete enough to allow even experienced Git users to perform almost all of their daily version control tasks directly from within Emacs. While many fine Git clients exist, only Magit and Git itself deserve to be called porcelains.

I love it. You could get the same functionality with other text editors too but none so light wieght or polished in my opinion.
#+BEGIN_SRC emacs-lisp
(use-package magit
:ensure t
:init
(progn
(bind-key "C-x g" 'magit-status)))
#+END_SRC
*** Git-gutter
Display line changes in gutter based on git history. Enable it everywhere.
Originally a Sublime Text plug-in to show information about files in a git repository:
- Gutter Icons indicating inserted, modified or deleted lines
- Diff Popup with details about modified lines
- Status Bar Text with information about file and repository

and provides some commands like:
- Goto Change to navigate between modified lines
- Copy from Commit to copy the original content from the commit
- Revert to Commit to revert a modified hunk to the original state in a commit

#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :config
  (global-git-gutter-mode 't)
  :diminish git-gutter-mode)

;; If you would like to use git-gutter.el and linum-mode
;(git-gutter:linum-setup)

;; If you enable git-gutter-mode for some modes
(add-hook 'ruby-mode-hook 'git-gutter-mode)

(global-set-key (kbd "C-x C-g") 'git-gutter)
(global-set-key (kbd "C-x v =") 'git-gutter:popup-hunk)

;; Jump to next/previous hunk
(global-set-key (kbd "C-x p") 'git-gutter:previous-hunk)
(global-set-key (kbd "C-x n") 'git-gutter:next-hunk)

;; Stage current hunk
(global-set-key (kbd "C-x v s") 'git-gutter:stage-hunk)

;; Revert current hunk
(global-set-key (kbd "C-x v r") 'git-gutter:revert-hunk)

;; Mark current hunk
(global-set-key (kbd "C-x v SPC") #'git-gutter:mark-hunk)

(global-set-key (kbd "M-g M-g") 'hydra-git-gutter/body)
(defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
                              :hint nil)
    "
  Git gutter:
    _j_: next hunk        _s_tage hunk     _q_uit
    _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
    ^ ^                   _p_opup hunk
    _h_: first hunk
    _l_: last hunk        set start _R_evision
  "
    ("j" git-gutter:next-hunk)
    ("k" git-gutter:previous-hunk)
    ("h" (progn (goto-char (point-min))
                (git-gutter:next-hunk 1)))
    ("l" (progn (goto-char (point-min))
                (git-gutter:previous-hunk 1)))
    ("s" git-gutter:stage-hunk)
    ("r" git-gutter:revert-hunk)
    ("p" git-gutter:popup-hunk)
    ("R" git-gutter:set-start-revision)
    ("q" nil :color blue)
    ("Q" (progn (git-gutter-mode -1)
                ;; git-gutter-fringe doesn't seem to
                ;; clear the markup right away
                (sit-for 0.1)
                (git-gutter:clear))
         :color blue))
#+END_SRC
*** Time machine
TimeMachine lets us step through the history of a file as recorded in git. Visit a git-controlled file and issue M-x git-timemachine (or bind it to a keybinding of your choice). If you just need to toggle the time machine you can use M-x git-timemachine-toggle. Use the following keys to navigate historic version of the file:
- =p= Visit previous historic version
- =n= Visit next historic version
- =w= Copy the abbreviated hash of the current historic version
- =W= Copy the full hash of the current historic version
- =g= Goto nth revision
- =t= Goto revision by selected commit message
- =q= Exit the time machine.
- =b= Run magit-blame on the currently visited revision (if magit available).
- =c= Show current commit using magit (if magit available).
#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
:ensure t)
#+END_SRC
* Windmove
Windmove is a library built into GnuEmacs starting with version 21. It lets you move point from window to window using Shift and the arrow keys. This is easier to type than ‘C-x o’ and, for some users, may be more intuitive. 
#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings)
(global-set-key (kbd "C-c <left>")  'windmove-left)
(global-set-key (kbd "C-c <right>") 'windmove-right)
(global-set-key (kbd "C-c <up>")    'windmove-up)
(global-set-key (kbd "C-c <down>")  'windmove-down)
#+END_SRC
* Quickly visit certain files
As you keep using emacs or a specific desktop setup, you'll notice that you open certain files/folder more often than others, hence it's only sensible to set up key bindings that will open those specific files and save you the time of navigating through your file system.
- Emacs configuration
  #+BEGIN_SRC emacs-lisp
     (defun armacs/visit-emacs-config ()
     (interactive)
     (find-file "~/.emacs.d/config.org"))
     (global-set-key (kbd "C-c e") 'armacs/visit-emacs-config)
  #+END_SRC
- Resources
This is a habit of mine. Whenever a find some good material on a paricular topic I list it in this org file.A small description on what it is and a link to it. 
  #+BEGIN_SRC emacs-lisp
     (defun armacs/visit-resources ()
      (interactive)
      (find-file "~/Documents/Resources/resources.org"))
     (global-set-key (kbd "C-c r") 'armacs/visit-resources)
  #+END_SRC
- dotemacs
  I like to hoard good emacs configs. This org file lists them.
  #+BEGIN_SRC emacs-lisp
     (defun armacs/visit-dotemacs ()
     (interactive)
     (find-file "~/Documents/dotemacs/index.org"))
     (global-set-key (kbd "C-c d") 'armacs/visit-dotemacs)
  #+END_SRC
- sway Config file
  #+BEGIN_SRC emacs-lisp
     (defun armacs/visit-swayconfig ()
     (interactive)
     (find-file "~/.config/sway/config"))
     (global-set-key (kbd "C-c i") 'armacs/visit-swayconfig)
  #+END_SRC
* Parentheses
- When programming I like my editor to try to help me with keeping parentheses balanced.
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :diminish smartparens-mode
    :config
    (add-hook 'prog-mode-hook 'smartparens-mode))
#+END_SRC

- Highlight parens etc. for improved readability.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

* htmlize
  This package converts the buffer text and the associated decorations to HTML. To use it, just switch to the buffer you want HTML-ized and type M-x htmlize-buffer. You will be switched to a new buffer that contains the resulting HTML code. You can edit and inspect this buffer, or you can just save it with C-x C-w. M-x htmlize-file will find a file, fontify it, and save the HTML version in FILE.html, without any additional intervention. M-x htmlize-many-files allows you to htmlize any number of files in the same manner. M-x htmlize-many-files-dired does the same for files marked in a dired buffer.
  #+BEGIN_SRC emacs-lisp
   (use-package htmlize
   :ensure t)
   (setq org-html-postamble nil)
  #+END_SRC
* ox-reveal
  Makes org documents into presentations using js.
  #+BEGIN_SRC emacs-lisp
(use-package ox-reveal
:ensure ox-reveal)
(setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
(setq org-reveal-mathjax t)   
  #+END_SRC

  #+RESULTS:
  : t

* =dired=

Hide dotfiles by default, but toggle their visibility with =.=.
#+BEGIN_SRC emacs-lisp
  (use-package dired-hide-dotfiles
    :config
    (dired-hide-dotfiles-mode)
    (define-key dired-mode-map "." 'dired-hide-dotfiles-mode))
#+END_SRC

Open media with the appropriate programs.
#+BEGIN_SRC emacs-lisp
  (use-package dired-open
    :config
    (setq dired-open-extensions
          '(("pdf" . "zathura")
            ("mkv" . "mpv")
            ("mp3" . "mpv")
            ("mp4" . "mpv")
            ("webm" . "mpv")
            ("avi" . "mpv"))))
#+END_SRC

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".
#+BEGIN_SRC emacs-lisp
  (setq-default dired-listing-switches "-lhvA")
#+END_SRC

Kill buffers of files/directories that are deleted in =dired=.
#+BEGIN_SRC emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+END_SRC

Always copy directories recursively instead of asking every time.
#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

Ask before recursively /deleting/ a directory, though.
#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'top)
#+END_SRC

Open a file with an external program (that is, through =xdg-open=) by hitting
=C-c C-o=.
#+BEGIN_SRC emacs-lisp
  (defun dired-xdg-open ()
    "In dired, open the file named on this line."
    (interactive)
    (let* ((file (dired-get-filename nil t)))
      (call-process "xdg-open" nil 0 nil file)))
  (define-key dired-mode-map (kbd "C-c C-o") 'dired-xdg-open)
#+END_SRC
* Doom modeline 
    #+BEGIN_SRC emacs-lisp
    (use-package doom-modeline
    :ensure t
    :defer t
    :hook (after-init . doom-modeline-init))
    #+END_SRC
**** Customizations 
     #+BEGIN_SRC emacs-lisp
     ;; How tall the mode-line should be (only respected in GUI Emacs).
     (setq doom-modeline-height 25)
     
     ;; How wide the mode-line bar should be (only respected in GUI Emacs).
     (setq doom-modeline-bar-width 3)
     
     (setq doom-modeline-buffer-file-name-style 'truncate-upto-project)
     
     ;; What executable of Python will be used (if nil nothing will be showed).
     (setq doom-modeline-python-executable "python")
     
     ;; Whether show `all-the-icons' or not (if nil nothing will be showed).
     ;; The icons may not be showed correctly on Windows. Disable to make it work.
     (setq doom-modeline-icon t)
     
     ;; Whether show the icon for major mode. It should respect `doom-modeline-icon'.
     (setq doom-modeline-major-mode-icon t)
     
     ;; Whether display minor modes or not. Non-nil to display in mode-line.
     (setq doom-modeline-minor-modes nil)
     (setq find-file-visit-truename t)
     #+END_SRC

* Try
Sometimes if I'm not really sure about a package, I find it hard to convince myself to add them to my config just for the sake of trying it or to install them to find that I dont really like it and then uninstall it. This package let's me "try" stuff. It actually installs a package but only temporarely. Any package I install with try will be lost if and when I restart emacs.
#+BEGIN_SRC emacs-lisp
(use-package try
	:ensure t)
#+END_SRC

* org-bullets
Asterisk can be boring to look at.
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
:init
(add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC
* Menu bar
  Toggles reveal and hide menubar with the f10 key
  #+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (defun my-menu-bar-open-after ()
  (remove-hook 'pre-command-hook 'my-menu-bar-open-after)
  (when (eq menu-bar-mode 42)
  (menu-bar-mode -1)))
  (defun my-menu-bar-open (&rest args)
  (interactive)
  (let ((open menu-bar-mode))
  (unless open
  (menu-bar-mode 1))
  (funcall 'menu-bar-open args)
  (unless open
  (setq menu-bar-mode 42)
  (add-hook 'pre-command-hook 'my-menu-bar-open-after))))
  (global-set-key [f10] 'my-menu-bar-open)
  #+END_SRC
* Text
  - Fancy symbols
    #+BEGIN_SRC emacs-lisp
   (global-prettify-symbols-mode t)
    #+END_SRC
  - Highlight current line
    #+BEGIN_SRC emacs-lisp
    (global-hl-line-mode t)
    ;    (set-face-attribute 'hl-line nil :inherit nil :background "#1e2224")
    #+END_SRC
  - Fancy Font
      #+BEGIN_SRC emacs-lisp
;; set a default font
(when (member "Liberation Mono" (font-family-list))
  (set-face-attribute 'default nil :font "Liberation Mono"))
      #+END_SRC

* Org-mode
** Enable spell-checking in Org-mode.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook 'flyspell-mode)
   #+END_SRC
** Replacing (...)
   #+BEGIN_SRC emacs-lisp
  (setq org-ellipsis " ▶")
   #+END_SRC
** Exporting
   Allow export to markdown and beamer (for presentations).

   #+BEGIN_SRC emacs-lisp
     (require 'ox-md)
     (require 'ox-beamer)
   #+END_SRC

   Allow =babel= to evaluate Emacs lisp, Ruby, dot, or Gnuplot code.

   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
	(python . t)
	(C . t)))
   #+END_SRC
**** Exporting to HTML
     Don't include a footer with my contact and publishing information at the bottom
     of every exported HTML document.
     
     #+BEGIN_SRC emacs-lisp
     (setq org-html-postamble nil)
     #+END_SRC
     
     Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
     which checks the =$BROWSER= environment variable to choose the right browser.
     I'd like to always use Firefox, so:
     
     #+BEGIN_SRC emacs-lisp
     (setq browse-url-browser-function 'browse-url-generic
     browse-url-generic-program "firefox")
     
     (setenv "BROWSER" "firefox")
     #+END_SRC
**** Exporting to PDF 
- Open compiled PDFs in =zathura= instead of in the editor.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
        '(lambda ()
           (delete '("\\.pdf\\'" . default) org-file-apps)
           (add-to-list 'org-file-apps '("\\.pdf\\'" . "zathura %s"))))
#+END_SRC
**** Add bootstrap styled export.
#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs)
#+END_SRC
*** Extras
**** Writing
=writegood-mode= highlights bad word choices and has functions for calculating readability.
#+BEGIN_SRC emacs-lisp
  (use-package writegood-mode
    :bind ("C-c g" . writegood-mode)
    :config
    (add-to-list 'writegood-weasel-words "actionable"))
#+END_SRC

**** Stack Overflow
SX is a full stack overflow client within Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package sx
    :config
    (bind-keys :prefix "C-c s"
               :prefix-map my-sx-map
               :prefix-docstring "Global keymap for SX."
               ("q" . sx-tab-all-questions)
               ("i" . sx-inbox)
               ("o" . sx-open-link)
               ("u" . sx-tab-unanswered-my-tags)
               ("a" . sx-ask)
               ("s" . sx-search)))
#+END_SRC
** Easy-to-add emacs-lisp template
Hitting tab after an "<el" in an org-mode file will create a template for emacs-lisp insertion.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
	       '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
	       '("cp" "#+BEGIN_SRC c\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
	       '("py" "#+BEGIN_SRC python\n?\n#+END_SRC"))
#+END_SRC
* Scrolling
  -  System Scroll bars.
    #+BEGIN_SRC emacs-lisp
   (scroll-bar-mode -1)
    #+END_SRC
  -  Mini-buffer Scroll bars.
    #+BEGIN_SRC emacs-lisp
   (set-window-scroll-bars (minibuffer-window) nil nil)
    #+END_SRC
  - Scroll Smoothly and Conservatively
    #+BEGIN_SRC emacs-lisp
    (setq scroll-conservatively 100)
    #+END_SRC
* Configure =ivy= and =counsel=

I use =ivy= and =counsel= as my completion framework.

This configuration:

- Uses =counsel-M-x= for command completion,
- Replaces =isearch= with =swiper=,
- Uses =smex= to maintain history,
- Enables fuzzy matching everywhere except swiper (where it's thoroughly
  unhelpful), and
- Includes recent files in the switch buffer.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind
    ("M-x" . 'counsel-M-x)
    ("C-s" . 'swiper)

    :config
    (use-package flx)
    (use-package smex)

    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))))
#+END_SRC
* Beacon
Flashes the cursor's line when you scroll
  #+BEGIN_SRC emacs-lisp
   (use-package beacon
  :ensure t
  :config
  (beacon-mode 1)
  )
  #+END_SRC

* Cursor position
Show the current line and column for your cursor.
We are not going to have =relative-linum-mode= in every major mode, so this is useful.
#+BEGIN_SRC emacs-lisp
  (setq line-number-mode t)
  (global-set-key (kbd "C-c n") 'linum-mode)
#+END_SRC
* Enabling the clock
This turns on the clock globally.
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC
* C/C++
#+BEGIN_SRC emacs-lisp
(use-package ggtags
:ensure t
:config 
(add-hook 'c-mode-common-hook
          (lambda ()
            (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
              (ggtags-mode 1)))))
#+END_SRC
- C headers
  #+BEGIN_SRC emacs-lisp
  (use-package ac-c-headers
  :ensure t)
  #+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)
#+END_SRC
**** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
       (flycheck-clang-analyzer-setup)))
#+END_SRC
* Python
Emacs handles python quite well, but we can improve things with anaconda mode.
**** Anaconda
#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :config
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
#+END_SRC
**** Elpy
#+BEGIN_SRC emacs-lisp
(use-package elpy
:ensure t
:config
(elpy-enable))
#+END_SRC
**** Black 
Black is an opinionated pyton formatter. Install with =pip install black= so the command line tool is available.
#+BEGIN_SRC emacs-lisp
  (use-package blacken)
#+END_SRC

**** Kivy
Sometimes I use kivy.
#+BEGIN_SRC emacs-lisp
  (use-package kivy-mode
    :mode ("\\.kv\\'" . kivy-mode))
#+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
#+END_SRC
**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'flycheck-mode)
#+END_SRC
* Relative Line numbers
#+BEGIN_SRC emacs-lisp
(use-package linum-relative
  :ensure t
  :config
    (setq linum-relative-current-symbol "")
    (add-hook 'prog-mode-hook 'linum-relative-mode))
(linum-relative-global-mode 1)
#+END_SRC
